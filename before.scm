(define list (lambda v (letrec ((list-helper  (lambda (l) (if (null? l) '() (cons (car l) (list-helper (cdr l))))))) (list-helper v))))
(define map (lambda (f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst))))))
(define + (lambda lq (letrec ((rec (lambda (lst) (if (null? lst) 0 (plus-two (car lst) (rec (cdr lst))))))) (rec lq))))
(define - (lambda lq (if (null? (cdr lq)) (minus-two 0 (car lq)) (letrec ((rec (lambda (lst) (if (null? (cdr lst)) (car lst) (rec (cons (minus-two (car lst) (car (cdr lst))) (cdr (cdr lst)))))))) (rec lq)))))
(define * (lambda lq (letrec ((rec (lambda (lst) (if (null? lst) 1 (mul-two (car lst) (rec (cdr lst))))))) (rec lq))))
(define / (lambda lq (if (null? (cdr lq)) (div-two 1 (car lq)) (letrec ((rec (lambda (lst) (if (null? (cdr lst)) (car lst) (rec (cons (div-two (car lst) (car (cdr lst))) (cdr (cdr lst)))))))) (rec lq)))))
(define = (lambda lq (letrec ((rec (lambda (lst) (if (null? (cdr lst)) #t (and (math-eq-two (car lst) (car (cdr lst))) (rec (cdr lst)))))))   (rec lq))))
(define > (lambda lq (letrec ((rec (lambda (lst) (if (null? (cdr lst)) #t (and (math-greater-two (car lst) (car (cdr lst))) (rec (cdr lst)))))))   (rec lq))))
;(define < (lambda lq (not (or (apply = lq) (apply > lq)))))
(define append (letrec ((append-helper (lambda (lst1 s2) (if (null? lst1) s2 (cons (car lst1) (append-helper (cdr lst1) s2))))) 
	(append-helper2 (lambda (lst1 lst2) (if (null? lst2) lst1 (append-helper lst1 (append-helper2 (car lst2) (cdr lst2))))))) 
	(lambda lst2 (if (null? lst2) '() (append-helper2 (car lst2) (cdr lst2))))))
